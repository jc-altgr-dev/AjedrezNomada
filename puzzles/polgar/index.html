<script>
    let board, game = new Chess();
    let puzzles = [], currentIdx = 0, moves = [], step = 0;
    let timerStart, timerInt, stats = [], sessionStartTime;
    let puzzleAttempts = 1, sourceSq = null;

    const PIECE_THEMES = {
        local: 'img/{piece}.png',
        staunty: 'https://raw.githubusercontent.com/ornicar/lila/master/public/piece/staunty/{piece}.png',
        wikipedia: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
    };

    function getPieceTheme(piece) {
        const style = document.getElementById('piece-style').value;
        return PIECE_THEMES[style].replace('{piece}', piece);
    }

    async function quickSearch() {
        const id = parseInt(document.getElementById('search-id').value);
        if(!id) return alert("Ingresa un ID");
        loadPolgarRange(id, 4462, `Desde ID #${id}`);
    }

    async function loadPolgarRange(start, end, label) {
        try {
            const response = await fetch('puzzles.json');
            if (!response.ok) throw new Error("No se pudo leer puzzles.json");
            
            const data = await response.json();
            // Soporta si el JSON viene como array directo o dentro de un objeto "problems"
            const rawList = Array.isArray(data) ? data : (data.problems || []);
            
            puzzles = rawList.filter(p => {
                const pid = parseInt(p.problemid || p.ID || 0);
                return pid >= start && pid <= end;
            });

            if(puzzles.length === 0) throw new Error("Rango vacío");

            document.getElementById('screen-levels').classList.add('hidden');
            document.getElementById('screen-game').classList.remove('hidden');
            document.getElementById('btn-exit').classList.remove('hidden');
            document.getElementById('game-timer').classList.remove('hidden');
            document.getElementById('sub-title').innerText = label;
            
            currentIdx = 0;
            sessionStartTime = Date.now();
            loadPuzzle();

        } catch (err) {
            alert("Error de carga: " + err.message);
        }
    }

    function loadPuzzle() {
        const p = puzzles[currentIdx];
        
        // --- VALIDACIÓN DE DATOS (EL FIX CRÍTICO) ---
        const fen = p.FEN || p.fen;
        const movesStr = p.moves || p.move || p.Moves;

        if (!fen || !movesStr) {
            console.warn("Ejercicio incompleto detectado, saltando al siguiente...", p);
            currentIdx++;
            loadPuzzle();
            return;
        }

        // Intentar cargar FEN, si falla r es undefined
        const validFen = game.load(fen);
        if (!validFen) {
            console.error("FEN inválido en ID:", p.problemid);
            currentIdx++;
            loadPuzzle();
            return;
        }

        // Limpieza de movimientos
        const movesRaw = movesStr.replace(/-/g, '').replace(/\s/g, '');
        moves = movesRaw.match(/.{1,4}/g);
        
        if (!moves) {
            currentIdx++;
            loadPuzzle();
            return;
        }

        step = 0; 
        puzzleAttempts = 1;
        
        if (board) board.destroy(); // Limpiar tablero previo

        board = ChessBoard('myBoard', {
            draggable: true,
            onDrop: handleMove,
            onSnapEnd: () => board.position(game.fen()),
            pieceTheme: getPieceTheme
        });

        board.orientation(game.turn() === 'w' ? 'white' : 'black');
        board.position(game.fen());
        
        updateUI();
        startPuzzleTimer();
        setFeedback("Tu turno. Busca el mate.", "info");

        $('.square-55d63').unbind().on('mousedown touchstart', function(e) {
            e.preventDefault();
            handleTap($(this).data('square'));
        });
    }

    function handleMove(src, tgt) {
        // Evitar que el usuario mueva si no es su turno (por si acaso)
        const piece = game.get(src);
        if (!piece || piece.color !== game.turn()) return 'snapback';

        const uci = src + tgt;
        const move = game.move({ from: src, to: tgt, promotion: 'q' });

        if (!move) return 'snapback';

        // Comprobación flexible de movimientos
        const expectedMove = moves[step];
        const isCorrect = (uci === expectedMove || (uci + 'q') === expectedMove);

        if (isCorrect || game.in_checkmate()) {
            step++;
            if (game.in_checkmate() || step >= moves.length) {
                finishPuzzle(true);
            } else {
                setTimeout(() => {
                    const nextMove = moves[step];
                    game.move(nextMove, {sloppy: true});
                    step++;
                    board.position(game.fen());
                    updateUI();
                    if(game.in_checkmate()) finishPuzzle(true);
                }, 400);
            }
        } else {
            game.undo();
            puzzleAttempts++;
            document.getElementById('ui-attempts').innerText = puzzleAttempts;
            setFeedback("Incorrecto. Intenta otra vez.", "fail");
            return 'snapback';
        }
    }

    // El resto de funciones (finishPuzzle, startPuzzleTimer, etc.) se mantienen igual que la versión anterior.
    // Asegúrate de incluirlas para que el reporte y el cronómetro funcionen.
</script>
